# Tests
This module is where we store all of the tests that _use_ the testing harness. This is not the place to test out the harness itself - that's what the `TestHarness` module is for!

## Aion kernel setup

The tests will automatically start the kernel(s) that it needs to test against.  They expect the Java and Rust kernels to be at a particular location, so this must be set up before the tests can be run successfully.  Kernel configuration will be automatically copied as part of test execution.

Assuming that you have a directory named `node_test_harness` where you've cloned the Git repository:
- For Java kernel, extract the release to `node_test_harness/Tests/aion` (so that `aion.sh` is present in that directory)
- For Rust kernel, extract the release to `node_test_harness/Tests/aionr` (so that `aion` is present in that directory)

## Concurrent testing framework
The tests in this module have the ability to be incorporated into a test suite that is run concurrently against a single node instance. This allows us to not only gain a huge speed-up in terms of how long it takes for all of the tests to run, but it also allows for our individual functional tests to come together and serve as a stress test of the kernel, by flooding it with transactions simultaneously.

__All tests should be written for concurrent testing unless there is a very good reason why they do not fit into the concurrent model!__

In general, `./gradlew :Tests:test` is how you should be running tests (this will use the concurrent runner and execute the tests against both Java and Rust kernels).  To test against only one kernel, use `./gradlew :Tests:test -PtestNodes=java` or `./gradlew :Tests:test -PtestNodes=rust`


* [Concurrent Testing](#concurrent)
  * [Writing tests to be run concurrently](#concurrent-writing)
  * [Running tests concurrently](#concurrent-run)
* [Sequential Testing](#sequential)
  * [Writing tests to be run sequentially](#sequential-writing)
  * [Running tests sequentially](#sequential-run)

### <a name="concurrent">Concurrent Testing</a>
### <a name="concurrent-writing">Writing tests to be run concurrently</a>
Every test defined in your class will be run on a unique instance of the class. This means if your test only accesses instance methods and fields then no synchronization is required on your part. If your tests access static other external resources, then you will need to synchronize them appropriately.

Your tests never touch the node! All node management and life-cycling is taken care of behind the scenes by the runner. The node is started up once before any tests are run, and shut down once all tests have been run, so that every test in the concurrent suite is interacting with the same node instance.

The following two JUnit Rules are provided: `PreminedAccount` should be used as the only safe means of interacting with a premined account; `LocalNodeListener` is used to listen for events on the node.

Your tests must use these rules! Since you have no access to the node itself, you cannot start up your own listener, and if you try and use the pre-mined account defined in the genesis block then you will introduce race conditions and concurrency issues into the system! These rules are here to simplify things for you and delegate concurrency concerns elsewhere.

__Step 1.__ Write your tests like typical JUnit tests, using the two provided Rules.

__Step 2.__ Annotate your test class with the following annotation: `@RunWith(SequentialRunner.class)`. This allows your tests to be run sequentially (since you now depend on external node lifecycling, Rules, etc. for your test to run, you require a JUnit Runner that knows how to do this stuff).

__Step 3.__ Open the `ConcurrentSuite.java` class and add your test class into the list of `SuiteClasses`. This allows your test to be run concurrently.

### <a name="concurrent-run">Running tests concurrently</a>
If you are running your tests from an IDE, then to run the tests concurrently simply run the `ConcurrentSuite.java` class as a test class. By default, the log files will be deleted when the tests finish. To prevent this from happening, set the System Property `skipCleanLogs=true`.

If you are running your tests from the command line, then navigate to the root directory of the node harness project and run `./gradlew :Tests:test`. By default, the log files will be deleted when the tests finish. To prevent this from happening, run `./gradlew :Tests:test -PskipCleanLogs=true`.

These log files are your best means of debugging if you run into problems. You can find the logs generated by a test in the `logs` directory in the `Tests` module. Do not modify these logs while tests are running!

### <a name="sequential">Sequential Testing</a>
### <a name="sequential-writing">Writing tests to be run sequentially</a>
If there is a very good reason why the tests you are writing cannot fit into the concurrent test suite model, then it is still recommended that you use the provided `SequentialRunner` custom JUnit runner. The runner takes the burden of node lifecycle management off you, and opens this test up to easily being integrated into the concurrent model in the future if this ever becomes a possibility.

If the `SequentialRunner` does not meet your needs for some reason then write your tests as regular JUnit tests.

Otherwise, write your tests as regular JUnit tests but use the provided Rule `PreminedAccount` to interact with your unique premined account, and `LocalNodeListener` to listen to the log messages of the node. The runner will start up and shut down the node for you, your tests should not ever need to touch an instance of the node itself.

Finally, annotate your test class with: `@RunWith(SequentialRunner.class)` to enable the sequential runner. That's all.

### <a name="sequential-run">Running tests sequentially</a>
If you are running your tests from an IDE, then to run the test sequentially simply run your test class regularly. Note that the sequential runner will run every test in the class every time, there is no way to single out a specific test to run unless you `@Ignore` the other tests.

If you are running your tests from the command line, then navigate to the root directory of the node harness project and run `./gradlew :Tests:test -Psequential`. By default, the log files will be deleted when the tests finish. To prevent this from happening, run `./gradlew :Tests:test -Psequential -PskipCleanLogs=true`.

These log files are your best means of debugging if you run into problems. You can find the logs generated by a test in the `logs` directory in the `Tests` module. Do not modify these logs while tests are running!

### <a name="sequential-run">Multi-kernel behaviour</a>

By default, running tests sequentially will cause the test to be run twice -- once with Java kernel, then a second time with Rust kernel.  This behaviour can be overridden (for invocation from IDE or Gradle) by adding the JVM system property `testNodes`.  Value values are: `rust`, `java`, or `rust,java`.  Example Gradle invocation: `./gradlew :Tests:test -Psequential -PskipCleanLogs=true -PtestNodes=java`. 

